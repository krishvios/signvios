/*!
 * \file RateHistoryManager.cpp
 * \brief Saves/loads rate history per IP to/from a file.  It also can
 *        calculate the median of saved rates.  This is used by
 *        RecordFlowControl to know what rate it should start sending at in a
 *        new call.
 *
 * Sorenson Communications Inc. Confidential. --  Do not distribute
 * Copyright 2017 Sorenson Communications, Inc. -- All rights reserved
 */

#include "RateHistoryManager.h"
#include "stiAssert.h"
#include "stiTools.h"
#include "stiOS.h"
#include <iterator>
#include <cstdlib>
#include <fstream>

namespace vpe
{


const std::string RATE_HISTORY_FILE = "data_rate_history.csv";

const uint32_t RATE_HISTORY_LIMIT = 5;



RateHistoryManager::RateHistoryManager ()
{
	// Construct the rate history filename
	stiOSDynamicDataFolderGet (&m_filename);
	m_filename += RATE_HISTORY_FILE;
}


/*!
 * \brief Loads up to m_rateLimit rates per ip from a file and populates m_rateMap
 */
bool RateHistoryManager::loadFile ()
{
	std::ifstream ifs (m_filename);
	std::string line;
	bool failed = false;

	if (!ifs.is_open())
	{
		stiASSERTMSG (false, "Unable to read rate history file\n");
		return false;
	}

	while (std::getline(ifs, line))
	{
		auto tokens = splitString(line, ',');
		if (tokens.size() < 2)
		{
			stiASSERTMSG (false, "Malformed rate history file\n");
			failed = true;
			continue;
		}

		const std::string &ipAddress = tokens[0];
		auto rateList = splitString (tokens[1], ' ');
		int remaining = RATE_HISTORY_LIMIT;

		for (auto &rateStr : rateList)
		{
			// Only save the first N rates to file
			uint32_t rate = strtoul (rateStr.c_str(), nullptr, 10);
			if (rate > 0 && remaining-- > 0)
			{
				m_rateMap[ipAddress].push_back (rate);
			}
		}
	}

	ifs.close ();
	return !failed;
}


/*!
 * \brief Writes up to RATE_HISTORY_LIMIT rates to file per ip address
 */
bool RateHistoryManager::saveFile ()
{
	std::ofstream ofs (m_filename);
	if (!ofs.is_open())
	{
		stiASSERTMSG (false, "Unable to write rate history to file\n");
		return false;
	}

	for (auto &kv : m_rateMap)
	{
		const auto &ipAddress = kv.first;
		const auto &rates = kv.second;
		std::string line = ipAddress + ",";
		int remaining = RATE_HISTORY_LIMIT;

		for (auto rate : rates)
		{
			// Only save the first N rates
			if (remaining-- > 0)
			{
				line += std::to_string (rate) + " ";
			}
		}

		ofs << line << std::endl;
	}

	ofs.close ();
	return true;
}


/*!
 * \brief Adds a new rate to the history and saves it to file
 */
void RateHistoryManager::saveRate (
	const std::string &ipAddress,
	uint32_t rate)
{
	auto &rates = m_rateMap[ipAddress];
	rates.push_front (rate);

	// Discard older rates that would push us past our save limit
	while (rates.size() > RATE_HISTORY_LIMIT)
	{
		rates.pop_back();
	}

	saveFile ();
}


/*!
 * \brief Calculates the median rate for a given ip address
 */
uint32_t RateHistoryManager::medianRateGet (
	const std::string &ipAddress)
{
	// If we haven't loaded the file already, do so now
	if (m_rateMap.empty())
	{
		// Load the rate history file, but if it doesn't exist (or is empty),
		// try loading the legacy Autospeed rate file
		if (!loadFile() || m_rateMap.empty())
		{
			stiTrace ("RateHistoryManager: Loading rates from legacy file\n");
			loadLegacyFile();
		}
	}

	// If the ip address doesn't exist, return 0 for the rate
	if (m_rateMap.count(ipAddress) == 0)
	{
		return 0;
	}

	// Sort the rate list
	auto sortedRates = m_rateMap[ipAddress];
	sortedRates.sort ();

	// Select the center rate (median)
	auto index = sortedRates.size() / 2;
	auto itr = sortedRates.begin();
	std::advance (itr, index);

	return *itr;
}



/*!
 * \brief Reads rates from a file generated by AutoSpeed.  We only fall back to
 *        reading this file if RATE_HISTORY_FILE does not exist, which will be
 *        the case when using TMMBR in a call for the very first time
 */
bool RateHistoryManager::loadLegacyFile ()
{
	uint32_t lastRate = 0;
	double dummy = 0.0;
	std::string filename;
	stiOSDynamicDataFolderGet (&filename);
	filename += "data_rates.dat";

	char ipAddress[48];

	FILE *fp = fopen (filename.c_str (), "r");
	if (fp)
	{
		int ret = 0;
		while ((ret = fscanf(fp, "%47s\t%u\t%lf\n", ipAddress, &lastRate, &dummy)) != EOF)
		{
			if (ret != 3)
			{
				break;
			}

			stiTrace ("Adding to rateMap: '%s':%u", ipAddress, lastRate);
			m_rateMap[ipAddress].push_back (lastRate);
		}

		fclose (fp);
		return true;
	}

	return false;
}


} // namespace vpe
